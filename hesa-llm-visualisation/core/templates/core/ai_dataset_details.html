{% extends 'base.html' %}
{% load static %}

{% block title %}{{ dataset_title }} | HESA Data{% endblock %}

{% block extra_css %}
<style>
    .table-container {
        overflow-x: auto;
        max-height: 600px;
        overflow-y: auto;
        /* Ensure scrollbar is always visible if content overflows */
        scrollbar-width: thin;
    }
    
    /* Style for tables with more than 10 rows */
    .table-container.scrollable {
        max-height: 400px;
    }
    
    .table-container::-webkit-scrollbar {
        width: 8px;
    }
    .table-container::-webkit-scrollbar-thumb {
        background-color: #cbd5e0;
        border-radius: 4px;
    }
    .table-container::-webkit-scrollbar-track {
        background-color: #f1f5f9;
    }
    
    .year-column {
        background-color: #ebf5ff;
    }
    
    @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; }
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    .animate-fade-out {
        animation: fadeOut 0.3s forwards;
    }
    
    .animate-fade-in {
        animation: fadeIn 0.5s forwards;
    }
    
    .chart-type-btn.active {
        background-color: #EBF5FF;
        border-color: #3B82F6;
        color: #1E40AF;
        font-weight: 500;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    
    .chart-type-btn {
        transition: all 0.3s ease;
    }
    
    .chart-type-btn:active {
        transform: scale(0.95);
    }
    
    /* Darker input field borders */
    input, textarea, select {
        border-width: 2px !important;
        border-color: #9CA3AF !important; /* gray-400 */
    }
    
    input:focus, textarea:focus, select:focus {
        border-color: #3B82F6 !important; /* blue-500 */
    }
</style>
{% endblock %}

{% block content %}
<div class="max-w-7xl mx-auto px-4 py-8">
    <!-- Back Button -->
    <div class="mb-6">
        <a href="{% url 'core:ai_dashboard' %}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded-md text-sm flex items-center inline-flex">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
            </svg>
            <span>Back to AI Dashboard</span>
        </a>
    </div>
    
    <!-- Dataset Title -->
    <h1 class="text-3xl font-bold mb-4">{{ dataset_title }}</h1>
    
    <!-- Query Information -->
    <div class="bg-blue-50 shadow-md rounded-lg p-6 mb-8 border border-blue-200">
        <h2 class="text-xl font-semibold mb-4 text-blue-800">Query Information</h2>
        
        <div class="mb-4">
            <p class="font-medium text-gray-700">Your query:</p>
            <p class="text-blue-800 bg-blue-100 p-2 rounded">{{ query }}</p>
        </div>
        
        {% if corrected_query %}
        <div class="mb-4">
            <p class="font-medium text-gray-700">Corrected query:</p>
            <p class="text-green-700 bg-green-50 p-2 rounded">{{ corrected_query }}</p>
        </div>
        {% endif %}
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div class="border rounded p-3">
                <p class="font-medium text-gray-700">Institutions:</p>
                <ul class="list-disc list-inside">
                    {% for institution in institutions %}
                        <li>{{ institution }}</li>
                    {% empty %}
                        <li class="text-gray-500">None specified</li>
                    {% endfor %}
                </ul>
            </div>
            
            {% if original_institutions and original_institutions != institutions %}
            <div class="border rounded p-3">
                <p class="font-medium text-gray-700">Original Institutions (with typos):</p>
                <ul class="list-disc list-inside">
                    {% for institution in original_institutions %}
                        <li>{{ institution }}</li>
                    {% empty %}
                        <li class="text-gray-500">None specified</li>
                    {% endfor %}
                </ul>
            </div>
            {% endif %}
            
            <div class="border rounded p-3">
                <p class="font-medium text-gray-700">Years:</p>
                <ul class="list-disc list-inside">
                    {% for year in years %}
                        <li>{{ year }}</li>
                    {% empty %}
                        <li class="text-gray-500">None specified</li>
                    {% endfor %}
                </ul>
            </div>
        </div>
    </div>
    
    <!-- Dataset Files -->
    <div class="bg-white shadow-md rounded-lg p-6 mb-8">
        <h2 class="text-xl font-semibold mb-4">Dataset Results</h2>
        
        {% if has_data %}
            {% for result in file_results %}
                <div class="border rounded-lg p-4 mb-6 hover:bg-gray-50 transition-colors">
                    <h3 class="font-semibold text-blue-800 text-lg mb-3">{{ result.academic_year }} - {{ result.reference }}</h3>
                    
                    {% if result.error %}
                        <div class="bg-red-100 text-red-700 p-4 rounded">
                            <p class="font-bold">Error:</p>
                            <p>{{ result.error }}</p>
                        </div>
                    {% else %}
                        {% if result.data %}
                            {% with row_count=result.data|length %}
                            <div class="overflow-x-auto {% if row_count > 10 %}table-container scrollable{% else %}table-container{% endif %} border rounded">
                                <table class="min-w-full border-collapse table-auto text-sm">
                                    <thead>
                                        <tr>
                                            {% for column in result.columns %}
                                                <th class="px-4 py-2 border-b border-gray-300 text-left text-sm font-medium sticky top-0 bg-white z-10">{{ column }}</th>
                                            {% endfor %}
                                            {% if "Academic Year" not in result.columns %}
                                            <th class="px-4 py-2 border-b border-gray-300 text-left text-sm font-medium sticky top-0 bg-white z-10 year-column">Academic Year</th>
                                            {% endif %}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for row in result.data %}
                                            <tr>
                                                {% for cell in row %}
                                                    <td class="px-4 py-2 border-b border-gray-300 text-sm">{{ cell }}</td>
                                                {% endfor %}
                                                {% if "Academic Year" not in result.columns %}
                                                <td class="px-4 py-2 border-b border-gray-300 text-sm year-column">{{ result.academic_year }}</td>
                                                {% endif %}
                                            </tr>
                                        {% empty %}
                                            <tr>
                                                <td colspan="{{ result.columns|length|add:1 }}" class="px-4 py-2 text-center text-gray-500">
                                                    No data available or no matching institutions found
                                                </td>
                                            </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                            {% endwith %}
                            
                            {% if result.matched_rows and result.data|length < result.matched_rows %}
                                <div class="text-xs text-gray-500 mt-2">
                                    Showing {{ result.data|length }} of {{ result.matched_rows }} matching rows
                                </div>
                            {% endif %}
                        {% else %}
                            <div class="text-sm text-gray-500 p-3 bg-gray-50 rounded">
                                No data available for the requested institutions
                            </div>
                        {% endif %}
                    {% endif %}
                </div>
            {% endfor %}
        {% else %}
            <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-yellow-700">
                            No data found for the selected institutions in this dataset. Try a different institution or dataset.
                        </p>
                    </div>
                </div>
            </div>
        {% endif %}
    </div>

    <!-- Data Visualization Section -->
    <div class="border-t-2 border-gray-300 my-8"></div>

    <div class="max-w-5xl mx-auto bg-white p-4 md:p-6 rounded-lg shadow-md my-8">
        <h2 class="text-xl font-semibold mb-4">Data Visualization</h2>
        
        <!-- Chart Type Selection -->
        <div id="chartRecommendation" class="bg-blue-50 p-4 rounded-lg mb-4">
            <p class="text-blue-800">Based on this dataset, Gemini recommends a <span id="recommendedChartType">loading...</span> for visualization.</p>
            <p id="recommendationReason" class="text-sm mt-2"></p>
        </div>
        
        <!-- Chart type buttons -->
        <div class="mb-4">
            <p class="text-sm font-medium mb-2">Select visualization type:</p>
            <div id="chartRecommended" class="text-sm italic mb-2"></div>
            <div id="chartRecommendationReason" class="text-sm mb-2"></div>
            <div class="flex flex-wrap gap-2">
                <button id="barChartBtn" class="chart-type-btn px-3 py-2 bg-blue-100 hover:bg-blue-200 rounded text-sm flex items-center" data-chart-type="bar">
                    <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2 11h2v4H2v-4zm4-5h2v9H6V6zm4-3h2v12h-2V3zm4 4h2v8h-2V7z"></path>
                    </svg>
                    <span class="font-medium">Bar Chart</span>
                    <span class="ml-1 text-xs italic text-blue-700">enforced when selected</span>
                </button>
                <button id="lineChartBtn" class="chart-type-btn px-3 py-2 bg-blue-100 hover:bg-blue-200 rounded text-sm flex items-center" data-chart-type="line">
                    <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2 10h2v7H2v-7zm4-5h2v12H6V5zm4-3h2v15h-2V2zm4 5h2v10h-2V7z"></path>
                    </svg>
                    <span class="font-medium">Line Chart</span>
                    <span class="ml-1 text-xs italic text-blue-700">enforced when selected</span>
                </button>
                <button id="pieChartBtn" class="chart-type-btn px-3 py-2 bg-blue-100 hover:bg-blue-200 rounded text-sm flex items-center" data-chart-type="pie">
                    <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10 2a8 8 0 100 16 8 8 0 000-16zm0 14.5a6.5 6.5 0 110-13 6.5 6.5 0 010 13z"></path>
                        <path d="M10 0v10l7.071 7.071a10 10 0 01-14.142 0A10 10 0 010 10C0 4.477 4.477 0 10 0z"></path>
                    </svg>
                    <span class="font-medium">Pie Chart</span>
                    <span class="ml-1 text-xs italic text-blue-700">enforced when selected</span>
                </button>
            </div>
        </div>
        
        <!-- Compatibility Warning -->
        <div id="chartCompatibilityWarning" class="hidden mb-4"></div>
        
        <!-- Example Prompts Section (Combined) -->
        <div id="examplesSection" class="mb-4">
            <p class="text-sm font-medium mb-2">Try one of these examples:</p>
            <ul id="examplePromptsList" class="list-disc pl-5 text-sm">
                <li class="animate-pulse">Loading example prompts...</li>
            </ul>
        </div>
        
        <!-- Visualization Request Form -->
        <div class="mb-4">
            <label for="visualizationRequest" class="block text-sm font-medium text-gray-700 mb-1">Describe what you'd like to visualize:</label>
            <textarea id="visualizationRequest" rows="3" class="w-full rounded-md border-2 border-gray-400 shadow-sm focus:border-blue-400 focus:ring focus:ring-blue-200 focus:ring-opacity-50"></textarea>
            <button id="generateVisualization" class="mt-2 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Generate Visualization</button>
        </div>
        
        <!-- Loading Indicator -->
        <div id="visualizationLoading" class="hidden flex justify-center items-center p-4">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-700"></div>
            <span class="ml-2">Generating visualization...</span>
        </div>
        
        <!-- Error Display -->
        <div id="visualizationError" class="hidden p-4 bg-red-50 border border-red-200 rounded-md mb-4">
            <p id="visualizationErrorMessage" class="text-red-700"></p>
        </div>
        
        <!-- Alternative Suggestions -->
        <div id="alternativeSuggestions" class="hidden p-4 bg-blue-50 border border-blue-200 rounded-md mb-4">
            <p class="font-medium mb-2">Try one of these suggestions instead:</p>
            <ul id="suggestionsList" class="list-disc pl-5"></ul>
        </div>
        
        <!-- Visualization Container -->
        <div id="visualizationContainer" class="hidden mt-4">
            <div class="border rounded-md p-4 bg-white">
                <canvas id="visualizationChart" width="400" height="200"></canvas>
            </div>
            <div class="mt-4">
                <h3 class="text-lg font-semibold flex items-center mb-2 text-blue-700">
                    <span class="mr-2">ðŸ’¡</span> Insights
                </h3>
                <div id="insightsContent" class="p-4 bg-gray-50 rounded-md border border-gray-200"></div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Include Chart.js library -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Get dataset information from the page
    const datasetTitle = document.querySelector('h1').textContent;
    const tables = document.querySelectorAll('table');
    
    if (tables.length === 0) {
        console.error("No tables found on the page");
        showError("Could not find data tables on the page");
        return;
    }
    
    // Prepare combined dataset info
    let columns = [];
    let allRows = [];
    let years = [];
    
    // Get academic years from the section headers
    const sectionHeaders = document.querySelectorAll('.border.rounded-lg h3');
    sectionHeaders.forEach(header => {
        const headerText = header.textContent.trim();
        const yearMatch = headerText.match(/^(\d{4}\/\d{2})/);
        if (yearMatch) {
            years.push(yearMatch[1]);
        }
    });
    
    console.log("Years detected from headers:", years);
    
    // Process all tables to combine data
    tables.forEach((tableElement, tableIndex) => {
        // Extract columns from first table only (assuming all tables have same structure)
        if (tableIndex === 0) {
            const tableHeaders = tableElement.querySelectorAll('thead th');
            tableHeaders.forEach(th => {
                columns.push(th.textContent.trim());
            });
        }
        
        // Extract rows with year information
        const tableRows = tableElement.querySelectorAll('tbody tr');
        const year = years[tableIndex] || 'Unknown';
        
        tableRows.forEach(tr => {
            const rowData = [];
            tr.querySelectorAll('td').forEach(td => {
                rowData.push(td.textContent.trim());
            });
            
            // Add the academic year to each row
            allRows.push({
                data: rowData,
                year: year
            });
        });
    });
    
    // Get query information
    let query = "";
    const queryElements = document.querySelectorAll('.bg-blue-50 p');
    queryElements.forEach(el => {
        if (el.textContent.trim().startsWith("Your query:")) {
            query = el.textContent.trim().replace("Your query:", "").trim();
        }
    });
    
    // Get institutions
    const institutions = [];
    const institutionLists = document.querySelectorAll('.border ul');
    institutionLists.forEach(ul => {
        if (ul.parentElement.textContent.includes("Institutions:")) {
            ul.querySelectorAll('li').forEach(li => {
                const inst = li.textContent.trim();
                if (inst && !inst.includes("None specified")) {
                    institutions.push(inst);
                }
            });
        }
    });
    
    // Create dataset info object
    const datasetInfo = {
        title: datasetTitle,
        columns: columns,
        rows: allRows.map(row => row.data), // For backward compatibility
        years: years,
        allYearData: allRows, // New property containing year information
        query: query,
        institutions: institutions
    };
    
    // Make dataset info available globally
    window.datasetInfo = datasetInfo;
    
    console.log("Dataset info collected:", datasetInfo);
    
    // Check if we have a stored recommendation
    try {
        const storedRecommendation = localStorage.getItem('originalRecommendation');
        if (storedRecommendation) {
            originalRecommendation = JSON.parse(storedRecommendation);
            console.log("Loaded stored recommendation:", originalRecommendation);
        }
    } catch (e) {
        console.error("Error loading stored recommendation:", e);
    }
    
    // Get initial chart recommendation
    getChartRecommendation(datasetInfo);
    
    // Set up event listener for generate button
    document.getElementById('generateVisualization').addEventListener('click', function() {
        const request = document.getElementById('visualizationRequest').value;
        if (!request) {
            showError("Please describe what you'd like to visualize.");
            return;
        }
        
        // Update current request
        currentRequest = request;
        
        generateVisualization(datasetInfo, request);
    });

    // Set up suggestion click handler
    document.getElementById('suggestionsList').addEventListener('click', function(e) {
        // Check if clicked element is a suggestion
        if (e.target.tagName === 'LI') {
            document.getElementById('visualizationRequest').value = e.target.textContent;
        }
    });
    
    // Set up example prompts click handler
    document.getElementById('examplePromptsList').addEventListener('click', function(e) {
        // Check if clicked element is an example prompt
        if (e.target.classList.contains('example-prompt-item')) {
            document.getElementById('visualizationRequest').value = e.target.textContent;
            // Focus the textarea
            document.getElementById('visualizationRequest').focus();
        }
    });
    
    // Set up chart type button click handlers
    document.querySelectorAll('.chart-type-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            // Get chart type from button's data attribute
            const chartType = this.getAttribute('data-chart-type');
            
            // Call the change chart type function
            changeChartType(chartType);
            
            // Set this button as active visually
            setActiveChartButton(chartType);
            
            console.log(`Chart type button clicked: ${chartType}`);
        });
    });

    // Set up chart type button event listeners
    document.getElementById('barChartBtn').addEventListener('click', function() {
        changeChartType('bar');
    });
    
    document.getElementById('lineChartBtn').addEventListener('click', function() {
        changeChartType('line');
    });
    
    document.getElementById('pieChartBtn').addEventListener('click', function() {
        changeChartType('pie');
    });
});

// Add this as a global variable to store the original recommendation
let originalRecommendation = null;
let currentRequest = '';

// Update the getChartRecommendation function to store the original recommendation
function getChartRecommendation(datasetInfo) {
    const loadingEl = document.getElementById('visualizationLoading');
    const recommendationEl = document.getElementById('chartRecommendation');
    const reasonEl = document.getElementById('recommendationReason');
    const chartTypeEl = document.getElementById('recommendedChartType');
    const examplePromptsList = document.getElementById('examplePromptsList');
    
    // Show loading state
    loadingEl.classList.remove('hidden');
    
    console.log("Sending chart recommendation request with data:", datasetInfo);
    
    // Prepare data for API call
    const requestData = {
        action: 'get_recommendation',
        dataset_info: datasetInfo
    };
    
    // Call backend API for Gemini recommendation
    fetch('/visualization_api/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
        },
        body: JSON.stringify(requestData)
    })
    .then(response => {
        console.log("Received recommendation response status:", response.status);
        return response.json();
    })
    .then(data => {
        // Hide loading state
        loadingEl.classList.add('hidden');
        console.log("Recommendation data:", data);
        
        // Update recommendation
        if (data.success) {
            // Store the original recommendation for future reference
            originalRecommendation = {
                recommended_chart_type: data.recommended_chart_type,
                recommendation_reason: data.recommendation_reason,
                example_prompts: data.example_prompts
            };
            
            // Save to localStorage for persistence
            localStorage.setItem('originalRecommendation', JSON.stringify(originalRecommendation));
            
            // Update UI
            chartTypeEl.textContent = data.recommended_chart_type;
            reasonEl.textContent = data.recommendation_reason;
            recommendationEl.classList.remove('hidden');
            
            // Set the active chart type button based on recommendation
            setActiveChartButton(data.recommended_chart_type);
            
            // Update example prompts if available
            if (data.example_prompts && data.example_prompts.length > 0) {
                updateExamplePrompts(data.example_prompts);
            }
        } else {
            showError(data.error || "Failed to get chart recommendation");
        }
    })
    .catch(error => {
        loadingEl.classList.add('hidden');
        showError("Network error: " + error.message);
        console.error("Error getting chart recommendation:", error);
    });
}

// Helper function to update example prompts with animation
function updateExamplePrompts(prompts) {
    const examplePromptsList = document.getElementById('examplePromptsList');
    
    if (!examplePromptsList) {
        console.error("Example prompts list element not found");
        return;
    }
    
    // Add fade-out animation
    examplePromptsList.classList.add('animate-fade-out');
    
    // Wait for animation to complete before updating content
    setTimeout(() => {
        // Clear existing prompts
        examplePromptsList.innerHTML = '';
        
        // Add new prompts
        prompts.forEach(prompt => {
            const li = document.createElement('li');
            li.textContent = prompt;
            li.classList.add('hover:text-blue-600', 'hover:underline', 'cursor-pointer', 'example-prompt-item');
            examplePromptsList.appendChild(li);
        });
        
        // Add fade-in animation
        examplePromptsList.classList.remove('animate-fade-out');
        examplePromptsList.classList.add('animate-fade-in');
        
        // Remove animation class after animation completes
        setTimeout(() => {
            examplePromptsList.classList.remove('animate-fade-in');
            
            // Add click handlers to examples
            document.querySelectorAll('#examplePromptsList li').forEach(li => {
                li.addEventListener('click', function() {
                    const requestInput = document.getElementById('visualizationRequest');
                    if (requestInput) {
                        requestInput.value = this.textContent;
                        requestInput.focus();
                    }
                });
            });
        }, 500);
    }, 300);
}

// Function to handle chart type changes
function changeChartType(chartType) {
    // Don't do anything if we haven't received the original recommendation yet
    if (!originalRecommendation) {
        console.warn("Cannot change chart type before receiving original recommendation");
        return;
    }
    
    const loadingEl = document.getElementById('visualizationLoading');
    const recommendationEl = document.getElementById('chartRecommendation');
    const reasonEl = document.getElementById('recommendationReason');
    const chartTypeEl = document.getElementById('recommendedChartType');
    
    // Show loading state
    loadingEl.classList.remove('hidden');
    
    // Get the current visualization request if any
    currentRequest = document.getElementById('visualizationRequest').value || '';
    
    // Prepare data for API call
    const requestData = {
        action: 'change_chart_type',
        dataset_info: window.datasetInfo, // Global variable set during page load
        chart_type: chartType,
        original_recommendation: JSON.stringify(originalRecommendation),
        current_request: currentRequest
    };
    
    console.log("Sending chart type change request:", requestData);
    
    // Call backend API
    fetch('/visualization_api/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
        },
        body: JSON.stringify(requestData)
    })
    .then(response => response.json())
    .then(data => {
        // Hide loading state
        loadingEl.classList.add('hidden');
        console.log("Chart type change response:", data);
        
        if (data.success) {
            // Use our new chart type info update function to handle all UI updates
            updateChartTypeInfo(data);
            
            // If there is a current visualization, regenerate it with the new chart type
            if (currentRequest && currentRequest.trim() !== '') {
                // Clear previous visualization
                if (window.currentChart) {
                    window.currentChart.destroy();
                    window.currentChart = null;
                }
                
                // Hide visualization container
                document.getElementById('visualizationContainer').classList.add('hidden');
                
                // Regenerate the visualization with the new chart type
                generateVisualization(window.datasetInfo, currentRequest, chartType);
            } else {
                // If there's no current request, just clear any existing visualization
                if (window.currentChart) {
                    window.currentChart.destroy();
                    window.currentChart = null;
                }
                document.getElementById('visualizationContainer').classList.add('hidden');
                document.getElementById('visualizationError').classList.add('hidden');
            }
        } else {
            showError(data.error || "Failed to change chart type");
        }
    })
    .catch(error => {
        loadingEl.classList.add('hidden');
        showError("Network error: " + error.message);
        console.error("Error changing chart type:", error);
    });
}

// Function to set active chart button
function setActiveChartButton(chartType) {
    // Normalize chart type name
    const normalizedChartType = chartType.toLowerCase();
    
    // Remove active class from all buttons
    document.querySelectorAll('.chart-type-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Determine which button to activate
    let buttonId = 'barChartBtn'; // Default to bar chart
    
    if (normalizedChartType.includes('bar')) {
        buttonId = 'barChartBtn';
    } else if (normalizedChartType.includes('line')) {
        buttonId = 'lineChartBtn';
    } else if (normalizedChartType.includes('pie')) {
        buttonId = 'pieChartBtn';
    }
    
    // Add active class to the selected button
    const activeButton = document.getElementById(buttonId);
    if (activeButton) {
        activeButton.classList.add('active');
    }
}

// Function to generate visualization based on user request
function generateVisualization(datasetInfo, request, chartType) {
    const loadingEl = document.getElementById('visualizationLoading');
    const errorEl = document.getElementById('visualizationError');
    const errorMsgEl = document.getElementById('visualizationErrorMessage');
    const alternativesEl = document.getElementById('alternativeSuggestions');
    const suggestionsListEl = document.getElementById('suggestionsList');
    const visualizationEl = document.getElementById('visualizationContainer');
    const insightsEl = document.getElementById('insightsContent');
    
    // Store the current request for future use
    currentRequest = request;
    
    // Hide previous results
    errorEl.classList.add('hidden');
    alternativesEl.classList.add('hidden');
    visualizationEl.classList.add('hidden');
    
    // Show loading state
    loadingEl.classList.remove('hidden');
    
    // Prepare data for API call
    const requestData = {
        action: 'generate_visualization',
        dataset_info: datasetInfo,
        user_request: request
    };
    
    // If a specific chart type was requested, include it
    if (chartType) {
        requestData.chart_type = chartType;
        
        // Set active chart button to reflect the selected type
        setActiveChartButton(chartType);
        
        // Add a confirmation that this chart type is being enforced
        console.log(`Enforcing chart type: ${chartType} for visualization`);
        
        // If the chart type wasn't specifically mentioned in the request, add info
        if (!request.toLowerCase().includes(chartType.toLowerCase())) {
            loadingEl.innerHTML = `<span class="text-sm text-blue-600">Generating a ${chartType} chart as requested...</span>`;
        }
    }
    
    // Call backend API for Gemini visualization generation
    fetch('/visualization_api/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken()
        },
        body: JSON.stringify(requestData)
    })
    .then(response => response.json())
    .then(data => {
        // Hide loading state
        loadingEl.classList.add('hidden');
        
        if (data.success) {
            // If successful, render the chart
            try {
                console.log("Chart config received:", data.chart_config);
                
                // Safely evaluate the chart configuration
                let chartConfig;
                try {
                    // First attempt: directly evaluate the config after cleaning it
                    const cleanConfig = data.chart_config
                        .replace(/Object\.assign/g, '')  // Remove Object.assign calls
                        .replace(/['"]\s*\+\s*['"]|['"]\s*\+|['"]\+\s*['"]|\+\s*['"]/g, '') // Fix string concatenation
                        .replace(/(['"])([\w\s]+)\1\s*:/g, '"$2":'); // Normalize property names to double quotes
                    
                    chartConfig = eval('(' + cleanConfig + ')');
                } catch (evalError) {
                    console.error("Error in first evaluation attempt:", evalError);
                    
                    // Second attempt: try to sanitize the config
                    try {
                        // Replace problematic quotes and syntax
                        let sanitizedConfig = data.chart_config
                            .replace(/Object\.assign/g, '')  // Remove Object.assign calls
                            .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2":') // Ensure property names are quoted
                            .replace(/:\s*(['"])([^'"]*)\1/g, ':"$2"') // Ensure property values use double quotes
                            .replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas
                        
                        chartConfig = JSON.parse(sanitizedConfig);
                    } catch (jsonError) {
                        console.error("Error in second evaluation attempt:", jsonError);
                        
                        // Third attempt: try to fix common issues with template literals and Object references
                        try {
                            let fixedConfig = data.chart_config
                                .replace(/Object/g, '') // Remove 'Object'
                                .replace(/\.assign/g, '') // Remove '.assign'
                                .replace(/`([^`]*)`/g, '"$1"') // Replace template literals with double quotes
                                .replace(/\$\{([^}]*)\}/g, '') // Remove template expressions
                                .replace(/\\/g, ''); // Remove escaped characters
                                
                            if (!fixedConfig.startsWith('{')) {
                                fixedConfig = '{' + fixedConfig;
                            }
                            if (!fixedConfig.endsWith('}')) {
                                fixedConfig = fixedConfig + '}';
                            }
                            
                            chartConfig = JSON.parse(fixedConfig);
                        } catch (lastAttemptError) {
                            // If all attempts fail, throw a more descriptive error
                            throw new Error("Could not parse chart configuration. The chart type may not be suitable for this data.");
                        }
                    }
                }
                
                // Only try to render if we have a valid chart config
                if (chartConfig && typeof chartConfig === 'object') {
                    // STRICTLY enforce the selected chart type
                    if (chartType) {
                        console.log(`Enforcing chart type: ${chartType} (was: ${chartConfig.type})`);
                        // Force the selected chart type to ensure it matches what the user selected
                        chartConfig.type = chartType;
                    }
                    
                    // Add compatibility warning if the chart configuration suggests a different type
                    if (chartType && data.has_compatibility_warning) {
                        console.log("Chart has compatibility warning");
                        insightsEl.innerHTML = `
                            <div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
                                <p class="font-bold">Note about ${chartType} chart:</p>
                                <p>${data.compatibility_warning || `A ${chartType} chart may not be the optimal choice for this data, but we've created one as requested.`}</p>
                            </div>
                        ` + (data.insights || "");
                    } else {
                        insightsEl.innerHTML = data.insights || "";
                    }
                    
                    // Render the chart with the evaluated configuration
                    renderChart(chartConfig);
                    
                    // Show insights
                    visualizationEl.classList.remove('hidden');
                } else {
                    throw new Error("Invalid chart configuration received");
                }
            } catch (e) {
                console.error("Error evaluating chart configuration:", e);
                
                // Create user-friendly error message based on the chart type
                let errorMessage = "The chart couldn't be displayed with your current request.";
                
                if (chartType) {
                    errorMessage = `Your ${chartType} chart couldn't be created with the selected data and requirements.`;
                    
                    // Add specific suggestions based on chart type
                    if (chartType === 'bar') {
                        errorMessage += `<br><br>Bar charts work best for comparing values across categories. Try a simpler request or use one of the examples below.`;
                    } else if (chartType === 'line') {
                        errorMessage += `<br><br>Line charts work best for showing trends over time. If your request doesn't include multiple time periods, try a different chart type.`;
                    } else if (chartType === 'pie') {
                        errorMessage += `<br><br>Pie charts work best for showing proportions of a whole with a small number of categories. If your request includes too many elements, try simplifying it.`;
                    }
                }
                
                errorMsgEl.innerHTML = errorMessage;
                errorEl.classList.remove('hidden');
            }
        } else {
            // Show error and suggestions if available
            errorMsgEl.textContent = data.error || "Failed to generate visualization";
            errorEl.classList.remove('hidden');
            
            if (data.alternatives && data.alternatives.length > 0) {
                // Clear previous suggestions
                suggestionsListEl.innerHTML = '';
                
                // Add new suggestions
                data.alternatives.forEach(suggestion => {
                    const li = document.createElement('li');
                    li.textContent = suggestion;
                    li.classList.add('cursor-pointer', 'hover:text-blue-700', 'mb-1');
                    suggestionsListEl.appendChild(li);
                });
                
                alternativesEl.classList.remove('hidden');
            }
        }
    })
    .catch(error => {
        loadingEl.classList.add('hidden');
        showError("Network error: " + error.message);
        console.error("Error generating visualization:", error);
    });
}

// Function to render Chart.js chart
function renderChart(chartConfig) {
    // Get the canvas element for rendering
    const canvas = document.getElementById('visualizationChart');
    const ctx = canvas.getContext('2d');
    
    try {
        // If we have a previous chart, destroy it properly
        if (window.currentChart) {
            window.currentChart.destroy();
            window.currentChart = null;
        }
        
        // In case the chart wasn't properly destroyed, clear the canvas manually
        canvas.width = canvas.width; // This effectively clears the canvas
        
        // Create a new chart with the provided configuration
        window.currentChart = new Chart(ctx, chartConfig);
        
        // Ensure chart is visible
        document.getElementById('visualizationContainer').classList.remove('hidden');
        document.getElementById('visualizationError').classList.add('hidden');
    } catch (error) {
        console.error("Error rendering chart:", error);
        
        // Display error to user with friendly message based on chart type
        let errorMessage = "The chart couldn't be displayed with your current settings.";
        
        if (chartConfig && chartConfig.type) {
            errorMessage = `Your ${chartConfig.type} chart couldn't be created with the selected data.`;
            errorMessage += "<br><br>Try selecting a different chart type or modifying your request.";
        }
        
        document.getElementById('visualizationErrorMessage').innerHTML = errorMessage;
        document.getElementById('visualizationError').classList.remove('hidden');
        document.getElementById('visualizationContainer').classList.add('hidden');
    }
}

// Helper function to show error message
function showError(message) {
    const errorEl = document.getElementById('visualizationError');
    const errorMsgEl = document.getElementById('visualizationErrorMessage');
    
    errorMsgEl.innerHTML = message;
    errorEl.classList.remove('hidden');
}

// Helper function to get CSRF token
function getCsrfToken() {
    const cookieValue = document.cookie
        .split('; ')
        .find(row => row.startsWith('csrftoken='))
        ?.split('=')[1];
        
    if (cookieValue) {
        return cookieValue;
    }
    
    // If no CSRF token in cookies, try to get it from the page meta tag
    const csrfInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
    if (csrfInput) {
        return csrfInput.value;
    }
    
    return '';
}

function updateChartTypeInfo(data) {
    // Update page UI with chart type recommendations and examples
    
    const chartRecommendedEl = document.getElementById('chartRecommended');
    const chartRecommendationReasonEl = document.getElementById('chartRecommendationReason');
    const chartWarningEl = document.getElementById('chartCompatibilityWarning');
    
    // Check if the elements exist before modifying them
    if (chartRecommendedEl) {
        // Update recommendation text
        chartRecommendedEl.textContent = data.recommended_chart_type ? 
            `Gemini's recommendation: ${data.recommended_chart_type}` : '';
    }
    
    if (chartRecommendationReasonEl) {
        // Update recommendation reason with justification
        chartRecommendationReasonEl.innerHTML = data.recommendation_reason ? 
            `<p class="my-2">${data.recommendation_reason}</p>` : '';
    }
    
    if (chartWarningEl) {
        // Add compatibility warning if present
        if (data.compatibility_warning) {
            chartWarningEl.innerHTML = `<div class="bg-amber-100 border border-amber-400 text-amber-800 px-4 py-2 mb-4 rounded">
                <strong>Note:</strong> ${data.compatibility_warning}
            </div>`;
            chartWarningEl.classList.remove('hidden');
        } else {
            chartWarningEl.innerHTML = '';
            chartWarningEl.classList.add('hidden');
        }
    }
    
    // Update example prompts using the combined function
    if (data.example_prompts && data.example_prompts.length > 0) {
        updateExamplePrompts(data.example_prompts);
    }
}
</script>
{% endblock %} 